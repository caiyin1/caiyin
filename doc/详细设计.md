详细设计
========




## 场景 upData 函数功能流程
```cpp
void upData(float at)
{
	switch(游戏状态)
	{
		case 游戏中：
			// 滚动3个layer,根据当前帧率控制屏幕下降高度
			rollLayer();
			// 获取需要检测碰撞的LaerData的ID
			int nLayerDataID = getNeedTestImpactLayerDataID();
			// 处理food的碰撞
			handleFoodImpact(nLayerDataID);
			// 处理block的碰撞逻辑	
			if(handleBlockImpact(nLayerDataID))
			{
				//  如果碰撞
				 上升一个蛇头的直径
			}
			else
			{
				// 未碰撞
				// 处理bar的碰撞
				handleBarImpact(nLayerDataID);
			}
			// 判断游戏是否结束
			if(gameOver())
			{
				 改变游戏状态
			}
		break；
		case 游戏暂停：
				  暂停upData()的回调
				break;
		case 游戏结束：
				 关闭upData()
				 关闭 onTouchmoved(), 蛇头指针指空
				 判断玩家是否刷新纪录，如果刷新纪录则改变最高纪录，反之不改变
				 玩家金币金币加1
				 存档
				 显示玩家得分，显示再来一局和返回主界面两个按钮。
		break；
	}
}
// 滚动3个layer,根据当前帧率控制屏幕下降高度
void rollLayer()
{
	
}

// 获取需要检测碰撞的LayerData的ID
int getNeedTestImpactLayerDataID();
// 处理foot的碰撞
void handleFoodImpact(int nLayerDataID)
{
	 通过nLayerDataID获取layerData
	 迭代layerData-> m_pFoodLayer中的所有food的进行碰撞判断
 	if(检测碰撞)
	{
		// 碰撞
		删除该碰撞的food
		蛇的身体增加对应的长度
	}
}
 
void handlebarImpact(int nLayerDataID)
{
 	if(检测碰撞)
	{
		// 碰撞
		根据玩家初始位置， 进行微移动。
	}
 
}
bool handleBlockImpact(int nLayerDataID)
{
	 通过nLayerDataID获取layerData
	 空判断
	 迭代layerData-> m_pFoodLayer中的所有Blcok的进行碰撞判断
	 {
		if（检测碰撞）
		{
			// 碰撞	
			格子的数值减1
			蛇的身体减1
			if(判断block的数子 < 1)
			{
				清除该block
			}
			return true;
		}
	}
	return false;
}

bool gameOver()
{
	return 蛇的身体 > 1 ? true : false;
}
````





### onTouchmoved()函数功能

```cpp
onTouchmoved()
{
	//判断蛇头为空 
	if(isSnakeHead())
	{
	  // 空代表蛇头不存在
	   return;
	}
	else
	{
		 判断符合碰撞检测要求的`layerData`返回对应的ID
		 先迭代判断所有的bar
		 计算鼠标X轴的偏移量 
		 获取`snakeHead`在`layerData`中的位置先对位置 `converTonodespace()` 得到snakePos
		 计算snakeHead的路径面积
		 检测snakeHead的路径面积和bar是否碰撞
		 if（`intersectRect()`）
		 {
		 	// 碰撞
			 修正X轴的偏移量，根据对比`snakeHead`的位置在`Bar`的左侧还是右侧 。对x轴的偏移量进行修正；
		 }
		  再迭代判断所有的block
		  重新计算`snakeHead`的路径面积
		  检测snakeHead的路径面积和block是否碰撞
		 if（`intersectRect()`）
		 {
		 	// 碰撞
			 修正X轴的偏移量，根据对比`snakeHead`的位置在`block`的左侧还是右侧 。对x轴的偏移量进行修正；
		 }
		 最后计算与`food`的判断 
		 重进计算`sankeHead`的面积
		 迭代改`layerData`中的所有的`food`;
		 检测`snakeHead`的路径面积和`food`的碰撞
		if(`intersectRect()`)
		{
			 碰撞 删除`food`, 蛇对应的增加`food`上的数量的尾巴
		}
	/根据最后的得到的x轴偏移量变换`snakeHead`的位置
	}
}
```
